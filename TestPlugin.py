# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TestPlugin
                                 A QGIS plugin
 此程式可選取主流河道某個位置之所有上游之集水區範圍。
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-02-06
        git sha              : $Format:%H$
        copyright            : (C) 2020 by 陳貴宏
        email                : cvb14795@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QMouseEvent
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QDialog
from qgis.gui import QgsMapTool, QgsMapToolIdentify, QgsMapToolIdentifyFeature, QgsProjectionSelectionWidget
from qgis.core import QgsMapLayerProxyModel, QgsWkbTypes, QgsProject, QgsMapLayer\
    , QgsVectorLayer, QgsVectorFileWriter, Qgis
from osgeo import ogr
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .TestPlugin_dialog import TestPluginDialog
from .save_dialog import Ui_Dialog
import os.path
from time import time

global point, features, ids
features = None
ids = []
point = [0, 0]

class Save_dialog(QDialog, Ui_Dialog):
    def __init__(self):
        super(Save_dialog, self).__init__()
        self.setupUi(self)
        self.mQgsFileWidget.setFilter("Shape File (*.shp)")
        self.mQgsFileWidget.setDialogTitle("請選擇輸出檔案位置")
        self.btn_ok.clicked.connect(self.click_ok)
        self.btn_cancel.clicked.connect(self.click_cancel)
        self.ok = False
        self.cancel = False

    def click_ok(self):
        self.ok = True
        self.close()

    def click_cancel(self):
        self.cancel = True
        self.reject()

    def closeEvent(self, event):
        if self.ok and self.mQgsProjectionSelectionWidget.crs().isValid() \
                and self.mQgsFileWidget.filePath() != ""\
                or self.cancel:
            event.accept()
        elif not self.mQgsProjectionSelectionWidget.crs().isValid():
            QMessageBox.warning(self, "提示", "選擇之座標系統不正確，請確認沒有後重新選取！")
            event.ignore()
            self.ok = False
        elif self.mQgsFileWidget.filePath() == "":
            QMessageBox.warning(self, "提示", "輸出之檔案路徑不得為空！")
            event.ignore()
            self.ok = False


class Update:
    def __init__(self, dlg):
        self.dlg = dlg
        self.flag = 0
        self.step = 0

    def get_src(self):
        driver = ogr.GetDriverByName("ESRI Shapefile")
        # 若SHP檔名與圖層重名 以|分割 只取SHP名(0)
        river_shp = self.dlg.mMapLayerComboBox.currentLayer().source().split('|')[0]
        watershed_shp = self.dlg.mMapLayerComboBox_2.currentLayer().source().split('|')[0]
        self.river_src = driver.Open(river_shp, 0)
        self.watershed_src = driver.Open(watershed_shp, 0)
        self.river_layer = self.river_src.GetLayer(0)
        self.watershed_layer = self.watershed_src.GetLayer(0)

    def reset(self):
        self.flag = 0
        self.step = 0
        self.river_src.Destroy()
        self.watershed_src.Destroy()

    def update_point(self, start_p, next_p, other_p):
        global ids
        if self.step == 0:
            self.get_src()
        p_r = ogr.CreateGeometryFromWkt("POINT (%f %f)" % (next_p[0], next_p[1]))
        self.river_layer.SetSpatialFilter(p_r)
        n = self.river_layer.GetFeatureCount()
        #print("偵測到other點下游共有: ", n, "點.")
        f_r = self.river_layer.GetNextFeature()
        self.watershed_layer.SetSpatialFilter(f_r.geometry())
        f_w = self.watershed_layer.GetNextFeature()
        while f_r is not None:
            g_r = f_r.GetGeometryRef()
            while f_w is not None:
                g_w = f_w.GetGeometryRef()  # 'POLYGON'
                #poly = g_w.GetGeometryRef(0)  # 'LINEARRING'
                # print("poly_w: ", [f_w.GetFID(), poly.GetX(0), poly.GetY(0)])
                if g_w.Intersect(f_r.geometry()):
                    if f_w.GetFID() in ids[self.flag:]:  # 要加的已在ids裡
                        # 以後從這位置往後找
                        self.flag = ids.index(f_w.GetFID())
                    else:
                        ids.append(f_w.GetFID())
                        # 更新計數器
                        self.step += 1
                f_w.Destroy()
                f_w = self.watershed_layer.GetNextFeature()
            x = g_r.GetX()
            y = g_r.GetY()
            other_p.append([x, y])
            f_r.Destroy()
            f_r = self.river_layer.GetNextFeature()
            self.watershed_layer.ResetReading()
            self.watershed_layer.SetSpatialFilter(None)
            # 更新進度條參數
            # 資料總數
            self.dlg.progressBar.setMaximum(len(ids))
            # 已計算資料數
            self.dlg.progressBar.setValue(self.step - 1)
            # 計算百分比
            bar_value = self.dlg.progressBar.value() / self.dlg.progressBar.maximum() * 100
            self.dlg.progressBar.setFormat("計算中... 進度: %.1f %%" % bar_value)
        p_r.Destroy()
        self.river_layer.ResetReading()
        self.river_layer.SetSpatialFilter(None)

        if n == 1:
            other_p = [next_p]
        #print("偵測到other點下游: ", other_p)  #扣掉自己
        return start_p, next_p, other_p


class ClickTool(QgsMapToolIdentify):
    def __init__(self, canvas, dlg):
        global features
        QgsMapToolIdentify.__init__(self, canvas)
        self.canvas = canvas
        self.dlg = dlg
        self.select_id = None
        self.tool = QgsMapToolIdentify(self.canvas)

    # 滑鼠按下時動作
    def canvasPressEvent(self, event):
        global point, features
        layer = self.dlg.mMapLayerComboBox.currentLayer()
        # point類型為QgsPointXY
        point = self.toMapCoordinates(self.canvas.mouseLastXY())
        # QgsPointXY轉list
        point = list(point)
        #print("\n---\n")
        #print("click (x,y): ", point)

        # 挑最上層layer選
        features = self.tool.identify(event.x(), event.y(), [layer],
                                      self.tool.TopDownStopAtFirst)
        #print(event.x(), event.y())


        if len(features) > 0:
            # here you get the selected feature
            feature = features[0].mFeature
            #print(list(feature.geometry().asMultiPolyline()))
            self.dlg.label_coor.setText("[{:<10.1f}, {:>10.1f}]".format(point[0], point[1]))
            #print("select ID: ", self.select_id)
            #print("click x,y: ", point[0], point[1])
            QMessageBox.information(self.dlg, "提示","您點擊了座標：[{:.1f} , {:.1f}]\n該圖徵ID：{:d}"
                                    .format(point[0], point[1], feature.id()))

        #print("select ID: ", feature.id())

    # 滑鼠放開時動作
    # def canvasReleaseEvent(self, e):
    # pass


class MouseTool(QgsMapToolIdentifyFeature):
    def __init__(self, canvas, dlg):
        QgsMapToolIdentifyFeature.__init__(self, canvas)
        self.canvas = canvas
        self.dlg = dlg
        #self.tool = QgsMapToolIdentifyFeature(self.canvas)

    # # 滑鼠放開時動作
    # def canvasReleaseEvent(self, event):
    #     #QMessageBox.information(self.dlg, "提示", "test")
    #     #print(event.x(), event.y())
    #     pass

class TestPlugin:
    """QGIS Plugin Implementation."""
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TestPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&TestPlugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.canvas = self.iface.mapCanvas()
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TestPlugin', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/TestPlugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'TestPlugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&TestPlugin'),
                action)
            self.iface.removeToolBarIcon(action)

    def start_calc(self):
        global point, features, ids
        start = time()
        if features is not None and len(features) > 0:
            feature = features[0].mFeature
            geom = feature.geometry()
            xy = list(geom.asMultiPolyline())
            self.count = 0

            # geom之點位順序: 下游(0)到上游(len(xy[0])
            # 上游
            start_p = list(xy[0][-1])
            # 下游
            next_p = list(xy[0][0])
            # 與下游連接之其他節點
            other_p = []
            start_p, next_p, other_p = self.update_.update_point(start_p, next_p, other_p)
            other_p.pop(other_p.index(next_p))
            self.select_watershed(start_p, next_p, other_p)
            self.update_.reset()
            self.layer_2.select(ids)
            self.finish = True
            # 計算完 變成最大值
            self.dlg.progressBar.setValue(self.dlg.progressBar.maximum())
            self.dlg.progressBar.setFormat("計算中... 進度: %.1f %%" % 100.0)
            end = time() - start
            print("程式執行耗時： {:.2f} 秒".format(end))
            # self.canvas.zoomToSelected()
            QMessageBox.information(self.dlg, "提示", "計算完畢，請確認選取結果!\n如有錯誤請點擊「打開/關閉修改工具」，移除不要的圖徵\n"
                                                 "待確認完畢後，點擊「儲存選取結果」將選取之集水區儲存為ShapeFile檔!")
            ids = []
        else:
            QMessageBox.warning(self.dlg, "提示", "沒有選取到任何圖徵，請確認目前選擇之圖層是否正確！")
            self.finish = False

    def select_watershed(self, start_p, next_p, other_p):
        global ids
        other_p1 = []
        self.count += 1
        if self.count == 1:
            self.read_end = False
            self.first_run = True

        for o in other_p:
            # print("\n計算下游點數: ", len(other_p))  # 扣掉自己
            # print("計算下游點: ", other_p)
            # print("迴圈在(", other_p.index(o) + 1, "of", len(other_p), ")")
            #  更新other_p
            if not self.read_end:
                start_p, next_p, other_p1 = self.update_.update_point(next_p, o, [])
            else:
                start_p, next_p, other_p1 = self.update_.update_point(start_p, o, [])
                self.read_end = False
            # print("start, next: ", start_p, next_p)
            # print("計算目標other點: ", o, "是否還有下游點")
            if len(other_p1) != 0:  # 後續點還有分支
                if other_p1 == [next_p]:  # 後續點只剩自己
                    # print("other_p已到下游盡頭")
                    self.read_end = True
                    other_p1.pop(other_p1.index(next_p))
                    continue
                other_p1.pop(other_p1.index(next_p))

            # print("other_p1: ", other_p1)
            self.select_watershed(start_p, next_p, other_p1)

    def show_clicktool(self):
        # 已經打開選取工具
        if self.canvas.mapTool().__class__.__name__ == "ClickTool":
            # 關閉
            self.canvas.unsetMapTool(self.canvas.mapTool())
        # 還沒打開
        else:
            self.canvas.setMapTool(self.clicktool)

    def show_mousetool(self):
        # 已經打開框選工具
        if self.canvas.mapTool().__class__.__name__ == "QgsMapTool":
            # 關閉
            self.canvas.unsetMapTool(self.canvas.mapTool())
        # 還沒打開
        else:
            self.canvas.setMapTool(self.mousetool)
            #self.iface.actionSelectRectangle().trigger()

    def unset_maptool(self):
        # 若要class名稱用self.canvas.mapTool().__class__.__name__獲取
        # 取消當前使用之工具
        self.canvas.unsetMapTool(self.canvas.mapTool())

    def reset(self):
        self.dlg.progressBar.reset()
        self.dlg.progressBar.setMinimum(0)
        self.dlg.progressBar.setValue(0)
        self.dlg.progressBar.setFormat("已計算: %d %%" % 0)
        self.layer.removeSelection()
        self.layer_2.removeSelection()

    def set_layer(self, layer):
        self.layer = self.dlg.mMapLayerComboBox.currentLayer()

    def set_layer_2(self, layer):
        self.layer_2 = self.dlg.mMapLayerComboBox_2.currentLayer()

    def save_to_shp(self):
        if self.finish:
            self.save_dlg = Save_dialog()
            self.save_dlg.show()
            res = self.save_dlg.exec_()
            print("res: ", res)
            if res == 0:
                fdir = self.save_dlg.mQgsFileWidget.filePath()
                crs = self.save_dlg.mQgsProjectionSelectionWidget.crs()
                print("fdir: ", fdir)
                usr_proj4 = self.layer_2.crs().toProj4()
                print(usr_proj4)
                # True: 僅輸出選取範圍
                error, error_string = QgsVectorFileWriter.writeAsVectorFormat(self.layer_2, fdir, 'utf-8'
                                                                              , crs, 'ESRI Shapefile', True)
                if error != QgsVectorFileWriter.NoError:
                    QMessageBox.critical(self.dlg, "錯誤", "寫入檔案時發生不明錯誤！\n錯誤訊息：" + error_string)
                else:
                    #QMessageBox.warning(self.dlg, "提示", "檔案輸出成功！\n檔案儲存在：" + fdir)
                    self.iface.messageBar().pushMessage(
                        "成功", "檔案輸出成功！\n檔案儲存在 " + fdir,
                        level=Qgis.Success, duration=3)
                    fname = os.path.split(fdir)[1]
                    f_basename, f_ext = os.path.splitext(fname)
                    file = QgsVectorLayer(fdir, f_basename, "ogr", QgsVectorLayer.LayerOptions())
                    QgsProject.instance().addMapLayer(file, True)
            elif res == 1:
                QMessageBox.warning(self.dlg, "提示", "視窗被使用者關閉，可能為Esc鍵造成\n請勿在輸出檔案時關閉視窗！")
        else:
            QMessageBox.information(self.dlg, "提示", "請先點擊「開始計算」以選取集水區！")
            self.finish = False

    def identify_select(self, f):
        self.layer_2.select(f.id())
        print("FID: ", f.id())

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.finish = False
            self.dlg = TestPluginDialog()
            self.maptool = QgsMapToolIdentify(self.canvas)
            self.clicktool = ClickTool(self.canvas, self.dlg)
            self.mousetool = MouseTool(self.canvas, self.dlg)

            # 圖層分類 (MultiLineString, MultiPolygon)
            layer_group = [[],[]]
            # 不要用self.canvas.layers() 沒打勾的layer無法獲取
            layers = list(QgsProject().instance().mapLayers().values())  # dict轉list
            for l in layers:  # QgsVectorLayer
                if l.wkbType() == QgsWkbTypes.MultiLineString and l.type() == QgsMapLayer.VectorLayer:
                    layer_group[0].append(l)
                if l.wkbType() == QgsWkbTypes.MultiPolygon and l.type() == QgsMapLayer.VectorLayer:
                    layer_group[1].append(l)
            # 控制UI連動function
            self.dlg.btn_start.clicked.connect(self.start_calc)
            self.dlg.btn_clicktool.clicked.connect(self.show_clicktool)
            self.dlg.btn_mousetool.clicked.connect(self.show_mousetool)
            self.dlg.btn_clear.clicked.connect(self.reset)
            self.dlg.btn_save.clicked.connect(self.save_to_shp)
            self.dlg.mMapLayerComboBox.layerChanged.connect(self.set_layer)
            self.dlg.mMapLayerComboBox_2.layerChanged.connect(self.set_layer_2)
            self.mousetool.featureIdentified.connect(self.identify_select)
            # 圖層下拉框 設定過濾規則
            # 河道
            self.dlg.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
            self.dlg.mMapLayerComboBox.setExceptedLayerList(layer_group[1])  # 只要河道不要集水區
            # 集水區
            self.dlg.mMapLayerComboBox_2.setFilters(QgsMapLayerProxyModel.VectorLayer)
            self.dlg.mMapLayerComboBox_2.setExceptedLayerList(layer_group[0])  # 只要集水區不要河道
            self.update_ = Update(self.dlg)
            self.layer = self.dlg.mMapLayerComboBox.currentLayer()
            self.layer_2 = self.dlg.mMapLayerComboBox_2.currentLayer()
            # 進度條
            self.dlg.progressBar.setMinimum(0)
            self.dlg.progressBar.setFormat("已計算: %d %%" % (self.dlg.progressBar.value()))

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            self.reset()
            self.unset_maptool()
            self.dlg.label_coor.setText("請使用選取工具點擊圖上任一圖徵...")
